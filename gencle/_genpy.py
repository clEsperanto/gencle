import textwrap


# code templates for a single function for pybind11
_wrapper_func_code = """
m.def(\"_{name}\", &cle::tier{tier}::{name}_func, "Call {name} from C++.",
    py::return_value_policy::take_ownership,
    {parameters_bindings});
""" 

# code templates for a tier with multiple function for pybind11
_wrap_code = """
// this code is auto-generated by the script 'pyclesperanto_autogen_tier_script.ipynb'.
// Do not edit manually. Instead, edit the script and run it again.
    
#include "pycle_wrapper.hpp"
#include "tier{tier}.hpp"

namespace py = pybind11;

auto tier{tier}_(py::module &m) -> void {{

    {function_code}

}}
"""

_docstring_code = """\"\"\"{brief_docstring}

    {parameters_docstring}
    {return_docstring}
    {links_docstring}
    \"\"\"
"""

# code templates for a single function for python
_python_func_code = """
@plugin_function{decorator_defines}
def {name}(
    {parameters_defines}
) -> {return_type}:
    {docstring}
    from ._pyclesperanto import _{name} as op

    return op(
        {parameters_bindings}
    )
"""

# code templates for a tier with multiple function for python
_python_code = """#
# This code is auto-generated from 'tier{tier}.hpp' file, using 'gencle' script.
# Do not edit manually.
#

from ._core import Device
from ._array import Image
from ._decorators import plugin_function
import numpy as np

{python_functions}
"""


def _generate_wrapper_function_code(tier: int, function_dict: dict) -> str:
    """Generate code for a single function.
    
    Parameters
    ----------
    tier : int
        Tier number.
    function_dict : dict
        Function dictionary (json-style).
    
    Returns
    -------
    str
        Code for a single function as pybind11 code.
    """
    function_name = function_dict['name']
    parameters_name = [p['name'] for p in function_dict['parameters']]
    parameters_bindings = ', '.join([f'py::arg("{p}")' for p in parameters_name])
    return _wrapper_func_code.format(name=function_name, tier=tier, parameters_bindings=parameters_bindings)


def generate_wrapper_code(tier: int, function_list: list) -> str:
    """Generate code for a single tier.
    
    Parameters
    ----------
    tier : int
        Tier number.
    function_list : list
        list of function diction (json-style) contained in tier.
    
    Returns
    -------
    str
        Code for a single tier as pybind11 code.
    """
    function_code = [_generate_wrapper_function_code(tier, f) for f in function_list]
    function_code = '\n\t'.join(function_code)
    return _wrap_code.format(tier=tier, function_code=function_code)


def _cpp_type_to_python_type(c_type: str) -> str:
    """Convert C++ type to Python type.
    
    Parameters
    ----------
    c_type : str
        C++ type.
    
    Returns
    -------
    str
        Python type.
    """
    # remove any const or reference from the type
    type = c_type.replace('const', '').replace('&', '')

    # if type is Array::Pointer, replace by Image, if type is Device::Pointer, replace by Device, if type contains 'std::array' or 'std::vector', replace by list
    if 'std::array' in type or 'std::vector' in type:
        type = 'list'
    if 'std::string' in type:
        type = 'str'
    if '::Pointer' in type:
        type = type.replace('Array::Pointer', 'Image').replace('Device::Pointer', 'Device')
    return type.strip()


def _cpp_to_python_argument(c_parameter: dict, extended: bool = False) -> str:
    """Convert C++ parameter to Python argument for the function call.
    
    Parameters
    ----------
    c_parameter : dict
        C++ parameter.
    
    Returns
    -------
    str
        Python argument.
    """
    name = c_parameter['name']
    type = c_parameter['type']
    default_value = c_parameter['default_value']

    # convert c_name to py_name
    name = name.replace('src', 'input_image').replace('dst', 'output_image')
    # convert c_type to py_type
    type = _cpp_type_to_python_type(type)
    # manage default value if any
    default = f' = {default_value}' if len(default_value) > 0 else ''
    if type == 'Device':
        default = f' = None'

    c_description = c_parameter['description']
    description = f"\n        {c_description}" if len(c_description) > 0 else ""

    # build argument string
    if extended:
        argument = f"{name}: {type}{default}{description}"
    else:
        argument = f"{name}: {type}{default}"
    return argument


def _cpp_to_python_bindings(c_parameter: dict) -> str:
    """Convert C++ parameter to Python bindings for the function call.

    Parameters
    ----------
    c_parameter : dict
        C++ parameter.

    Returns
    -------
    str
        Python bindings.
    """
    c_name = c_parameter['name']
    c_type = c_parameter['type']

    py_name = c_name.replace('src', 'input_image').replace('dst', 'output_image')
    if c_type in ['int', 'float', 'bool']:
        py_name = f'{c_type}({py_name})'
    bindings = f'{c_name}={py_name}'
    return bindings




def _build_docstring(function_dict: dict) -> str:
    """Build docstring from function dictionary.
    
    Parameters
    ----------
    function_dict : dict
        Function dictionary (json-style).
    
    Returns
    -------
    str
        Docstring.
    """
    name = function_dict['name']
    priority = function_dict['priority']
    category = function_dict['category']
    links = function_dict['link']
    brief = function_dict['brief']
    return_type = _cpp_type_to_python_type(function_dict['return'])
    parameters = function_dict['parameters']

    return_docstring = ''
    if len(return_type) > 0:
        return_docstring = f'Returns\n    -------\n    {return_type}'

    # add new line to brief after 120 characters (PEP8) and indent it with 4 spaces (PEP8) 
    brief_docstring=''
    if brief:
        brief_docstring = '\n    '.join(textwrap.wrap(brief, 80, break_long_words=False, break_on_hyphens=False))

    parameters_docstring = ''
    arguments = [_cpp_to_python_argument(p, extended=True) for p in parameters]
    if len(arguments) > 0:
        arguments.append(arguments.pop(0)) # move device argument to the end
        parameters_docstring = '\n    '.join(arguments)
        parameters_docstring = 'Parameters\n    ----------\n    ' + parameters_docstring + '\n'

    links_docstring = ''
    if len(links) > 0:
        links_docstring = [f'[{i+1}] {l}' for i, l in enumerate(links)]
        links_docstring = '\n\t'.join(links_docstring)
        links_docstring = '\n    References\n    ----------\n    ' + links_docstring
        
    return _docstring_code.format(brief_docstring=brief_docstring, parameters_docstring=parameters_docstring, 
                                  return_docstring=return_docstring, links_docstring=links_docstring)


def _generate_decorator_code(function_dict: dict) -> str:
    """Generate code for a single function.
    
    Parameters
    ----------
    function_dict : dict
        Function dictionary (json-style).
    
    Returns
    -------
    str
        Code for a single function as pybind11 code.
    """
    priority = function_dict['priority'] if function_dict['priority'] != "" else None
    category = function_dict['category'] if function_dict['category'] != "" else None
    category_defines = f'category=[{category}]' if category else ''
    priority_defines = f'priority={priority}' if priority else ''

    decorator_defines = ''
    if len(category_defines) > 0 and len(priority_defines) > 0:
        decorator_defines = f"({category_defines}, {priority_defines})"
    elif len(category_defines) > 0:
        decorator_defines = f"({category_defines})"
    elif len(priority_defines) > 0:
        decorator_defines = f"({priority_defines})"
    return decorator_defines


def _generate_python_function_code(function_dict: dict) -> str:
    """Generate code for a single function.

    Parameters
    ----------
    function_dict : dict
        Function dictionary (json-style).

    Returns
    -------
    str
        Code for a single function as Python code.
    """
    
    name = function_dict['name']
    return_type = _cpp_type_to_python_type(function_dict['return'])
    
    c_parameters = function_dict['parameters']

    arguments = [_cpp_to_python_argument(p, extended=False) for p in c_parameters]
    if len(arguments) > 0:
        arguments.append(arguments.pop(0)) # move device argument to the end
    parameters_defines = ',\n    '.join(arguments)

    bindings = [_cpp_to_python_bindings(p) for p in c_parameters]
    parameters_bindings = ',\n        '.join(bindings)

    docstring = _build_docstring(function_dict)
    decorator_defines = _generate_decorator_code(function_dict)

    # priority = function_dict['priority']
    # category = function_dict['category']
    # decorator_defines = ''

    return _python_func_code.format(decorator_defines=decorator_defines, name=name, 
                                    parameters_defines=parameters_defines, return_type=return_type, 
                                    docstring=docstring, parameters_bindings=parameters_bindings)


def generate_python_code(tier: int, function_list: list) -> str:
    """Generate code for a single tier.
    
    Parameters
    ----------
    tier : int
        Tier number.
    function_list : list
        list of function diction (json-style) contained in tier.
    
    Returns
    -------
    str
        Code for a single tier as Python code.
    """
    code_list = [_generate_python_function_code(f) for f in function_list]
    code = '\n\n'.join(code_list)
    return _python_code.format(tier=tier, python_functions=code)